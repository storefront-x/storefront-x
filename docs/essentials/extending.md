# Extending

Storefront X enables you to extend almost every file with some new add-on. Extensions are files with `.ext.*` suffix. They are special because **they don't override each other**. If two modules have the same extensions with the same names, both of the extensions will be applied.

You have to meet a few conditions before extending is possible:

- Before creating extension, original file has to exist
- Extensions must be placed in the same concept directory as the original file
- Extensions must have the same name as the file they extend (except the `.ext.*` suffix)
- Extension files must have `.ext.*` suffix at the end of their filename

::: info Example of creating extension file
`module-a/mappers/ToProduct.ts` is extended by `module-b/mappers/ToProduct.ext.ts`, `module-a/graphql/fragments/Product.ts` is extended by `module-b/graphql/fragments/Product.ext.ts`.
:::

::: warning
Native support for extensions is enabled for files generated by `IocConcept` (all files imported from `#ioc` directory).
:::

## What are extensions used to?

As it was said at the beginning, extensions can be used to extend functionality of existing files. For example you have a mapper in your common-module and you want to add an extra key mapping in your custom-module, extension is ideal solution to your problem.

### Example of using extensions in mappers concept

Let's imagine, you have a `ToProduct.ts` mapper (in a module-a), which is used to properly map back-end response to your key/value pairs.

```ts
// module-a/mappers/ToProduct.ts

import ToProduct from '#ioc/mappers/ToProduct'
import ToMoney from '#ioc/mappers/ToMoney'

export default (data: any) => ({
  __typename: data.__typename ?? '',
  id: (data.id ?? 0) as number,
  sku: (data.sku ?? '') as string,
  name: (data.name ?? '') as string,
  finalPrice: ToMoney(data.price_range?.minimum_price?.final_price ?? {}),
  crossSellProducts: (data.related_products ?? []).map(ToProduct),
  // ...
})
```

::: info
As we can see, the original file exports a function which takes one parameter (data to be mapped) and returns a mapped object.
:::

We want to add to that key/value pairs new property with our `module-b`. So, we create the same concept (folder structure) and the same file (with `.ext.ts` suffix) in a new module.

```ts
// module-b/mappers/ToProduct.ext.ts

import ToProductLabel from '#ioc/mappers/ToProductLabel'
import Extension from '#ioc/types/base/Extension'

interface Labels {
  labels: ReturnType<typeof ToProductLabel>[]
}

const ToProduct: Extension<Labels> = (ToProduct) => (data) => {
  const product = ToProduct(data)

  product.labels = data.product_labels?.items.map(ToProductLabel) ?? []

  return product
}

export default ToProduct
```

Extensions are simple functions with one input parameter: the thing they are extending. In this case it is the `ToProduct` mapper. Extensions need to return something that can be used same way as the thing they are extending. In this case, `ToProduct` mapper is a function that takes one argument (data) and returns object representing the product, this extension thus returns function with data input argument and mapped product as a result. Between that, we can do some stuff with the original data (eg. add `labels` property).

### Example of using extensions in services concept

In this example, we will try to solve the following issue, that is to add some functionality to existing composable. You have a `useLoginCustomer.ts` service inside a `services` concept. This service is a composable, so it returns a function inside the exported function. Its purpose is to logIn a user and set a cookie for him. You can see the example service bellow.

```ts
// customer-magento/services/useLoginCustomer.ts

import useLoginCustomerRepository from '#ioc/repositories/useLoginCustomerRepository'
import useCookies from '#ioc/composables/useCookies'
import MAGENTO_CUSTOMER_COOKIE_NAME from '#ioc/config/MAGENTO_CUSTOMER_COOKIE_NAME'

interface Options {
  redirect?: string
}

export default () => {
  const cookies = useCookies()
  const loginCustomerRepository = useLoginCustomerRepository()

  return async (email: string, password: string) => {
    const { token } = await loginCustomerRepository(email, password)

    cookies.set(MAGENTO_CUSTOMER_COOKIE_NAME, token, { path: '/' })
  }
}
```

You have another module `cart-magento`, there you want to add some functionality to the existing service `useLoginCustomer.ts`. You want to run the original service and also remove `MAGENTO_CART_COOKIE_NAME` from cookies. That is perfect fit for extensions. To do that, we create the same file (with `.ext`) in the same concept (`services/useLoginCustomer.ext.ts`).

```ts
// cart-magento/services/useLoginCustomer.ext.ts

import useCookies from '#ioc/composables/useCookies'
import MAGENTO_CART_COOKIE_NAME from '#ioc/config/MAGENTO_CART_COOKIE_NAME'

export default (useLoginCustomer: any) => () => {
  const loginCustomer = useLoginCustomer()
  const cookies = useCookies()

  return async (...args: any) => {
    await loginCustomer(...args)

    cookies.remove(MAGENTO_CART_COOKIE_NAME)
  }
}
```

Extension is once again a function which recieves original service as parameter and returns a function (outer function with context as in use()). This outer context function then returns async function which calls the service. As you can see we first call original service and then remove cookies.

And, that's it. Again, we can use extensions almost everywhere, in all concepts generated by `IocConcept`. <br />
Let's look, how it works in the background.

## How it works in the background?

Storefront X will look during build if there are some extension files for an original file. If there are, it will go through all of them and generate one file. Inside this file all extensions and original file are imported. This file exports latest extension (the latest module), as parameter it receives extension from previous module and so on. The final parameter is the original file.

```ts
// generated file by SFX
// .sfx/ioc/mappers/ToProduct.ts

import self from '~/modules/catalog-magento/mappers/ToProduct'
import ext0 from '~/modules/catalog-labels-magento/mappers/ToProduct.ext'
import ext1 from '~/modules/catalog-attributes-magento/mappers/ToProduct.ext'

export default ext1(ext0(self))
```
