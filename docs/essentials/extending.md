# Extending

Storefront X enables you to extend almost every file with some new add-on. Extensions are files with `.ext.*` suffix. They are special because **they don't override each other**. If two modules have same extensions with same names, all of the extensions will be applied.

For properly extension using there are a few conditions which have to be met:

- Before creating extension, original file has to be created
- Extensions have to be placed in the concept directory they interact with
- Extensions have to have the same name as the file they extend (except the `.ext.*` suffix)
- Extension files have to have `.ext.*` suffix in the end of their name

::: info Example of creating extension file
Eg. `module-a/mappers/ToProduct.ts` is extended by `module-b/mappers/ToProduct.ext.ts` and `module-a/graphql/fragments/Product.ts` is extended by `module-b/graphql/fragments/Product.ext.ts`.
:::

::: warning
You can only extend files generated by `IocConcept` (all files imported from `#ioc` directory).
:::

## What are extensions used to?

As it was said in the beginning, extensions can be used to extend functionality with some add-on functionality.

### Example of using extensions in mappers concept

Let's imagine, you have a `ToProduct.ts` mapper (in a global module), which is used to properly map the GraphQL output (response).

```ts
// module-a/mappers/ToProduct.ts

import ToProduct from '#ioc/mappers/ToProduct'
import ToMoney from '#ioc/mappers/ToMoney'

export default (data: any) => ({
  __typename: data.__typename ?? '',
  id: (data.id ?? 0) as number,
  sku: (data.sku ?? '') as string,
  name: (data.name ?? '') as string,
  finalPrice: ToMoney(data.price_range?.minimum_price?.final_price ?? {}),
  crossSellProducts: (data.related_products ?? []).map(ToProduct),
  // ...
})
```

::: info
As we can see, the original file returns a mapper object.
:::

But, we want, for example, display product labels in our code, conditionally, based on another module. So, we create the same concept and the same file (with `.ext.ts` suffix) in a new module.

```ts
// module-b/mappers/ToProduct.ext.ts

import ToProductLabel from '#ioc/mappers/ToProductLabel'
import Extension from '#ioc/types/base/Extension'

interface Labels {
  labels: ReturnType<typeof ToProductLabel>[]
}

const ToProduct: Extension<Labels> = (ToProduct) => (data) => {
  const product = ToProduct(data)

  product.labels = data.product_labels?.items.map(ToProductLabel) ?? []

  return product
}

export default ToProduct
```

In the example above we export a function _(exporting a function is necessary in extensions)_ with a one parameter `ToProduct`, which is the original object we are extending.
Inside it, we return another function which takes a `data` parameter _(because ToProduct mapper will take also an input data - which has to be mapped, not only an output data, like it is in the case below)_. Finally, we will do some stuff with original object (add `labels` property) and return it.

### Example of using extensions in services concept

We have a `useLoginCustomer.ts` service inside a `services` concept. This service is a composable, so it has to return a function inside exported function, like it is at the example below. If the composable is used in our code, `email` and `password` parameters are required.

```ts
// customer-magento/services/useLoginCustomer.ts

import useLoginCustomerRepository from '#ioc/repositories/useLoginCustomerRepository'
import useCookies from '#ioc/composables/useCookies'
import MAGENTO_CUSTOMER_COOKIE_NAME from '#ioc/config/MAGENTO_CUSTOMER_COOKIE_NAME'

interface Options {
  redirect?: string
}

export default () => {
  const cookies = useCookies()
  const loginCustomerRepository = useLoginCustomerRepository()

  return async (email: string, password: string, options: Options = {}) => {
    const { token } = await loginCustomerRepository(email, password)

    cookies.set(MAGENTO_CUSTOMER_COOKIE_NAME, token, { path: '/' })

    if (options.redirect) {
      window.location.href = options.redirect
    } else {
      window.location.reload()
    }
  }
}
```

Now, we want to implement `cart-magento` module with extended service, which will use the original one and it also will remove `MAGENTO_CART_COOKIE_NAME` from cookies. So, we create the same file in the same concept (`services/useLoginCustomer.ext.ts`).

```ts
// cart-magento/services/useLoginCustomer.ext.ts

import useCookies from '#ioc/composables/useCookies'
import MAGENTO_CART_COOKIE_NAME from '#ioc/config/MAGENTO_CART_COOKIE_NAME'

export default (useLoginCustomer: any) => {
  return () => {
    const loginCustomer = useLoginCustomer()
    const cookies = useCookies()

    return async (...args: any) => {
      await loginCustomer(...args)

      cookies.remove(MAGENTO_CART_COOKIE_NAME)
    }
  }
}
```

Exporting function (extensions have to always export a function) will use one parameter, which is the original function we are extending. Then, we return a function, because the original file also returning a function. Finally, we will return async function (so, we are able to use `await` keyword) with all arguments using rest parameter syntax, await original composable and remove the cookie.

And, that's it. Again, we can use extensions almost everywhere, in all concepts generated by `IocConcept`. <br />
Let's look, how it works in the background.

## How it works in the background?

SFX will look if there are extension files for an original file. If there are, it will go through all of them and generate one file where all of the extensions will call another ones and as a final parameter will be used the original file. It is the easiest way, how to extend original file and also each of its extension.

```ts
// generated file by SFX
// .sfx/ioc/mappers/ToProduct.ts

import self from '~/modules/catalog-magento/mappers/ToProduct'
import ext0 from '~/modules/catalog-labels-magento/mappers/ToProduct.ext'
import ext1 from '~/modules/catalog-attributes-magento/mappers/ToProduct.ext'

export default ext1(ext0(self))
```

::: tip
**Every extension has to export a function**, so it is able to call another extension. One exception is the original file. That file will never be used as a function in a generated file, so it can return anything.
:::
